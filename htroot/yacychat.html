<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>YaCy '#[clientname]#': Chat</title>
    #%env/templates/metas.template%#
    <style type="text/css">
      /* 1. Global Container */
      .chat-panel {
        width: 100%;
        color: #333333;
        padding: 0 0 32px 0; 
      }
    
      /* 2. Layout Structure */
      .chat-flow {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .chat-messages {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
    
      /* 3. The Message Blocks - Structural Look */
      .chat-turn {
        position: relative;
        border: 1px solid #e0e0e0;
        border-radius: 0px; 
        padding-top: 2px;
        padding-bottom: 12px;
        padding-left: 20px;
        padding-right: 20px;
        margin: 0;
        box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
        transition: all 0.2s;
      }
      .chat-turn:hover {
        box-shadow: 3px 3px 0px rgba(0,0,0,0.15); 
      }
    
      /* 4. Labels (User/Assistant Headers) - Headline Font Consistency */
      .chat-turn legend {
        font-family: inherit; 
        padding: 4px 10px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        border: 1px solid transparent;
        margin-bottom: 8px; /* Increased spacing */
      }
    
      /* --- USER: Lighter Grey Input --- */
      .chat-turn.user {
        background-color: #ECF1F8;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #d1d9e6;
        color: #2c3e50;
      }
      
      .chat-turn.user legend {
        background: #5092CF; 
        color: #ffffff;
        border: 1px solid #5092CF;
      }
    
      /* --- ASSISTANT: Darker Grey Output --- */
      .chat-turn.assistant {
        background-color: #DEE7F3;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #bbccdd;
        color: #000;
      }
    
      .chat-turn.assistant legend {
        background: #2c3e50; 
        color: #ffffff;
        border: 1px solid #2c3e50;
      }
    
      /* --- SYSTEM: Log Entry Style --- */
      .chat-turn.system {
        background: #fff3cd; 
        border: 1px solid #ffeeba;
        border-left: 5px solid #ffc107;
        color: #856404;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-size: 1.2rem;
      }
    
      /* 5. Typography - All Chat Content is MONOSPACE */
      .chat-body {
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 1.2rem; /* Larger font size */
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
      }
    
      /* 6. Composer Row (inside User fieldset) */
      .composer {
        display: flex;
        gap: 10px;
        align-items: stretch;
      }

      .chat-turn.user:focus-within {
        background-color: #ECF1F8;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #d1d9e6;
        color: #2c3e50;
      }

      .composer-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .composer textarea {
        flex: 0 0 auto;
        resize: none;
        border: none;
        background: transparent;
        padding: 0;
        margin: 0;
        outline: none;
        overflow-y: hidden;
      }

      .attachment-row {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.95rem;
        color: #2c3e50;
      }

      .attachment-row.has-attachment .attachment-clear {
        display: inline-flex;
      }
      .attachment-row.has-attachment .attachment-button {
        display: none;
      }

      .attachment-button {
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
        background: #d1d9e6;
        color: #2c3e50;
        font-weight: 800;
        font-size: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s;
      }

      .attachment-button:hover {
        background: #c3cbd9;
      }

      .attachment-filename {
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-size: 0.95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .attachment-clear {
        display: none;
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
        background: #d1d9e6;
        color: #2c3e50;
        font-weight: 800;
        font-size: 1.25rem;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s, color 0.15s;
      }

      .attachment-clear:hover {
        background: #c3cbd9;
      }

      .hidden-file-input {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }
    
      /* 7. The Button - Industrial Action */
      .composer .btn {
        align-self: stretch; 
        padding: 0 24px;
        border: 2px solid #555; 
        background: #333; 
        color: #fff;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
      }
    
      .composer .btn:hover {
        background: #0056b3;
        border-color: #0056b3;
      }
      
      .composer .btn:active {
        background: #004494;
      }
    
      @media (max-width: 900px) {
        .composer {
          flex-direction: column;
        }
        .composer .btn {
          width: 100%;
          border: 2px solid #555;
        }
      }

      .clear-chat-row {
        display: none;
        margin-top: 12px;
        gap: 10px;
        align-items: center;
      }

      .clear-chat-row .btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
    </style>
  </head>
  <body id="IndexControl">
    #%env/templates/header.template%#
    #%env/templates/submenuAI.template%#

    <h2>YaCy Chat</h2>
    <p>Chat with your configured LLM using the local YaCy settings. Requests are sent to the same host that served this page.</p>

      <div class="chat-panel">
        <div class="chat-flow">
          <div class="chat-messages" id="chatMessages" aria-live="polite"></div>
          <form id="chatForm">
            <fieldset class="chat-turn user">
              <legend>User</legend>
              <div class="composer">
                <div class="composer-main">
                  <textarea class="chat-body" id="userInput" rows="3" placeholder="Ask me anything..." required="required"></textarea>
                  <div class="attachment-row" id="attachmentRow">
                    <button type="button" class="attachment-button" id="addFileButton" aria-label="Attach an image">
                      <span class="glyphicon glyphicon-paperclip" aria-hidden="true"></span>
                    </button>
                    <button type="button" class="attachment-clear" id="clearFileButton" aria-label="Remove attached image">
                      <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
                    </button>
                    <span class="attachment-filename" id="attachmentFilename">Attach a PNG or JPG</span>
                    <input type="file" id="fileInput" class="hidden-file-input" accept="image/png,image/jpeg"/>
                  </div>
                </div>
                <input type="submit" class="btn btn-primary" id="sendButton" value="Send"/>
              </div>
            </fieldset>
          </form>
          <div class="clear-chat-row" id="clearChatRow">
            <button type="button" class="btn btn-inverse label-warning" id="clearChatButton" aria-label="Clear chat">
              <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
              Clear Chat
            </button>
            <button type="button" class="btn btn-inverse label-success" id="downloadChatButton" aria-label="Download chat">
              <span class="glyphicon glyphicon-download" aria-hidden="true"></span>
              Download Chat
            </button>
            <button type="button" class="btn btn-inverse label-primary" id="uploadChatButton" aria-label="Upload chat">
              <span class="glyphicon glyphicon-upload" aria-hidden="true"></span>
              Upload Chat
            </button>
            <input type="file" id="uploadChatInput" class="hidden-file-input" accept="application/json"/>
            <button type="button" class="btn btn-inverse label-info" id="toggleSystemButton" aria-label="Show system prompt">
              <span class="glyphicon glyphicon-star" aria-hidden="true"></span>
              <span class="toggle-label">Show System</span>
            </button>
          </div>
        </div>
      </div>

    <script type="text/javascript">
    const SYSTEM_PROMPT = 'You are a smart and helpful chatbot. If possible, use friendly emojies.';
    const defaultApiHost = '';

    const STORAGE_KEY = 'yacychat_recent_pairs';

    const state = {
        messages: [],
        config: {
            apiHost: defaultApiHost,
            model: 'chat',
            systemPrompt: SYSTEM_PROMPT
        },
        busy: false,
        attachment: null,
        assistantSeen: false,
        showSystem: false
    };

    const dom = {
        messages: document.getElementById('chatMessages'),
        form: document.getElementById('chatForm'),
        input: document.getElementById('userInput'),
        sendButton: document.getElementById('sendButton'),
        fileInput: document.getElementById('fileInput'),
        addFileButton: document.getElementById('addFileButton'),
        attachmentFilename: document.getElementById('attachmentFilename'),
        clearFileButton: document.getElementById('clearFileButton'),
        attachmentRow: document.getElementById('attachmentRow'),
        clearChatRow: document.getElementById('clearChatRow'),
        clearChatButton: document.getElementById('clearChatButton'),
        downloadChatButton: document.getElementById('downloadChatButton'),
        uploadChatButton: document.getElementById('uploadChatButton'),
        uploadChatInput: document.getElementById('uploadChatInput'),
        toggleSystemButton: document.getElementById('toggleSystemButton')
    };

    function scrollToBottom(smooth = true) {
        window.requestAnimationFrame(() => {
            const behavior = smooth ? 'smooth' : 'auto';
            window.scrollTo({ top: document.documentElement.scrollHeight, behavior });
        });
    }

    function formatTimestamp() {
        const now = new Date();
        const pad = (n, len = 2) => n.toString().padStart(len, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    function updateSystemToggleButton() {
        if (!dom.toggleSystemButton) return;
        const icon = dom.toggleSystemButton.querySelector('.glyphicon');
        if (icon) {
            icon.className = `glyphicon ${state.showSystem ? 'glyphicon-star-empty' : 'glyphicon-star'}`;
        }
        const label = state.showSystem ? 'Hide System' : 'Show System';
        dom.toggleSystemButton.querySelector('.toggle-label').textContent = label;
    }

    function appendMessage(role, text, opts = {}) {
        const { skipScroll = false, skipVisibilityUpdate = false } = opts;
        const entry = document.createElement('fieldset');
        entry.className = `chat-turn ${role}`;
        const legend = document.createElement('legend');
        if (role === 'assistant') {
            legend.textContent = 'Assistant';
        } else if (role === 'user') {
            legend.textContent = 'User';
        } else {
            legend.textContent = 'System';
        }
        entry.appendChild(legend);

        const body = document.createElement('div');
        body.className = 'chat-body';
        body.textContent = text;
        entry.appendChild(body);

        dom.messages.appendChild(entry);
        if (!skipScroll) {
            scrollToBottom();
        }
        if (!skipVisibilityUpdate && role === 'assistant') {
            state.assistantSeen = true;
            updateClearChatVisibility();
        }
        return body;
    }

    function clearAttachment() {
        state.attachment = null;
        dom.fileInput.value = '';
        dom.attachmentFilename.textContent = 'Attach a PNG or JPG';
        dom.attachmentRow.classList.remove('has-attachment');
    }

    function updateClearChatVisibility() {
        if (!dom.clearChatRow) return;
        dom.clearChatRow.style.display = state.assistantSeen ? 'block' : 'none';
        if (state.assistantSeen) {
            scrollToBottom();
        }
    }

    function clearChatHistory() {
        dom.messages.innerHTML = '';
        state.messages = [];
        state.assistantSeen = false;
        state.showSystem = false;
        localStorage.removeItem(STORAGE_KEY);
        updateClearChatVisibility();
        updateSystemToggleButton();
        dom.input.value = '';
        clearAttachment();
        resizeComposer();
    }

    function downloadChat() {
        const payload = buildRequestPayload();
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `yacychat-${formatTimestamp()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function applyUploadedChat(payload) {
        if (!payload || !Array.isArray(payload.messages)) {
            appendMessage('system', 'Invalid chat file.');
            return;
        }
        clearChatHistory();
        if (payload.model) {
            state.config.model = payload.model;
        }
        for (const msg of payload.messages) {
            if (!msg?.role || msg.content === undefined) continue;
            state.messages.push({ role: msg.role, content: msg.content });
        }
        renderConversation();
        persistConversation();
    }

    async function handleUploadChatFile(event) {
        const file = event.target.files && event.target.files[0];
        dom.uploadChatInput.value = '';
        if (!file) return;
        try {
            const text = await file.text();
            const parsed = JSON.parse(text);
            applyUploadedChat(parsed);
        } catch (err) {
            appendMessage('system', `Failed to load chat file: ${err.message}`);
        }
    }

    function ensureSystemMessage() {
        if (!state.messages.length || state.messages[0].role !== 'system') {
            state.messages.unshift({ role: 'system', content: state.config.systemPrompt });
        }
    }

    async function streamChat(userMessage) {
        ensureSystemMessage();
        const payload = {
            model: state.config.model,
            messages: [...state.messages, userMessage],
            stream: true
        };
        const headers = { 'Content-Type': 'application/json' };
        const response = await fetch(state.config.apiHost.replace(/\/$/, '') + '/v1/chat/completions', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload)
        });
        if (!response.ok) {
            throw new Error(`Request failed: ${response.status} ${response.statusText}`);
        }
        if (!response.body) {
            throw new Error('Streaming not supported by this browser.');
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let assistantText = '';
        const assistantNode = appendMessage('assistant', '...');
        const parseChunk = chunk => {
            const segments = chunk
                .split(/\n+/)
                .flatMap(line => line.split(/(?=data:)/))
                .map(line => line.trim())
                .filter(Boolean);
            for (const line of segments) {
                if (line === 'data: [DONE]' || line === '[DONE]') {
                    return true;
                }
                const clean = line.replace(/^data:\s*/i, '');
                if (!clean) continue;
                try {
                    const parsed = JSON.parse(clean);
                    const delta = parsed?.choices?.[0]?.delta?.content;
                    if (delta) {
                        assistantText += delta;
                        assistantNode.textContent = assistantText;
                        scrollToBottom(false);
                    }
                } catch (err) {
                    console.warn('Failed to parse line', line, err);
                }
            }
            return false;
        };
        let done = false;
        while (!done) {
            const { value, done: readerDone } = await reader.read();
            if (readerDone) break;
            const chunk = decoder.decode(value, { stream: true });
            done = parseChunk(chunk);
        }
        state.messages.push(userMessage);
        state.messages.push({ role: 'assistant', content: assistantText });
        persistConversation();
    }

    function resizeComposer() {
        const minHeight = 24;
        dom.input.style.height = 'auto';
        const measured = dom.input.scrollHeight || minHeight;
        dom.input.style.height = `${Math.max(minHeight, measured)}px`;
    }

    function buildUserMessage(promptText) {
        if (state.attachment?.dataUrl) {
            return {
                role: 'user',
                content: [
                    { type: 'text', text: promptText },
                    { type: 'image_url', image_url: { url: state.attachment.dataUrl } }
                ]
            };
        }
        return { role: 'user', content: promptText };
    }

    function buildRequestPayload() {
        ensureSystemMessage();
        return {
            model: state.config.model,
            messages: state.messages.map(m => ({ role: m.role, content: m.content })),
            stream: true
        };
    }

    function messageText(content) {
        if (typeof content === 'string') return content;
        if (Array.isArray(content)) {
            const textPart = content.find(part => part?.type === 'text');
            return textPart?.text || '';
        }
        if (content && typeof content === 'object' && typeof content.text === 'string') {
            return content.text;
        }
        return '';
    }

    function collectRecentPairs() {
        const pairs = [];
        let pendingUser = null;
        for (const msg of state.messages) {
            if (msg.role === 'user') {
                pendingUser = messageText(msg.content);
            } else if (msg.role === 'assistant' && pendingUser !== null) {
                pairs.push({ user: pendingUser, assistant: messageText(msg.content) });
                pendingUser = null;
            }
        }
        return pairs.slice(-3);
    }

    function renderConversation() {
        dom.messages.innerHTML = '';
        state.assistantSeen = state.messages.some(m => m.role === 'assistant');
        for (const msg of state.messages) {
            if (msg.role === 'system' && !state.showSystem) continue;
            appendMessage(msg.role, messageText(msg.content), { skipScroll: true, skipVisibilityUpdate: true });
        }
        updateClearChatVisibility();
        updateSystemToggleButton();
        scrollToBottom();
    }

    function persistConversation() {
        try {
            const pairs = collectRecentPairs();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(pairs));
        } catch (err) {
            console.warn('Failed to persist conversation', err);
        }
    }

    function hydrateConversation() {
        let stored = null;
        try {
            stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
        } catch (err) {
            console.warn('Failed to parse stored conversation', err);
        }
        if (!Array.isArray(stored) || !stored.length) return;
        for (const pair of stored) {
            if (pair?.user) {
                state.messages.push({ role: 'user', content: pair.user });
            }
            if (pair?.assistant) {
                state.messages.push({ role: 'assistant', content: pair.assistant });
            }
        }
        ensureSystemMessage();
        renderConversation();
    }

    function formatUserPreview(promptText) {
        if (state.attachment?.name) {
            return `${promptText}\n[Image attached: ${state.attachment.name}]`;
        }
        return promptText;
    }

    async function handleFileChange(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) {
            clearAttachment();
            return;
        }
        if (!file.type.startsWith('image/')) {
            appendMessage('system', 'Please upload a PNG or JPG image.');
            clearAttachment();
            return;
        }
        try {
            const dataUrl = await readFileAsDataURL(file);
            state.attachment = { name: file.name, dataUrl };
            dom.attachmentFilename.textContent = file.name;
            dom.attachmentRow.classList.add('has-attachment');
        } catch (err) {
            appendMessage('system', `Failed to read file: ${err.message}`);
            clearAttachment();
        }
    }

    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(file);
        });
    }

    dom.form.addEventListener('submit', async event => {
        event.preventDefault();
        if (state.busy) return;
        const prompt = dom.input.value.trim();
        if (!prompt) return;
        const userMessage = buildUserMessage(prompt);
        const preview = formatUserPreview(prompt);
        state.busy = true;
        dom.sendButton.disabled = true;
        appendMessage('user', preview);
        dom.input.value = '';
        clearAttachment();
        resizeComposer();
        try {
            await streamChat(userMessage);
        } catch (err) {
            appendMessage('system', `Error: ${err.message}`);
        } finally {
            state.busy = false;
            dom.sendButton.disabled = false;
        }
    });

    dom.addFileButton.addEventListener('click', () => {
        dom.fileInput.click();
    });
    dom.fileInput.addEventListener('change', handleFileChange);
    dom.clearFileButton.addEventListener('click', clearAttachment);
    dom.clearChatButton?.addEventListener('click', clearChatHistory);
    dom.downloadChatButton?.addEventListener('click', downloadChat);
    dom.uploadChatButton?.addEventListener('click', () => dom.uploadChatInput?.click());
    dom.uploadChatInput?.addEventListener('change', handleUploadChatFile);
    dom.toggleSystemButton?.addEventListener('click', () => {
        state.showSystem = !state.showSystem;
        renderConversation();
    });

    dom.input.addEventListener('input', resizeComposer);
    dom.input.addEventListener('keydown', event => {
        if (event.isComposing) return;
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (typeof dom.form.requestSubmit === 'function') {
                dom.form.requestSubmit(dom.sendButton);
            } else {
                dom.form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            }
        }
    });
    window.addEventListener('resize', resizeComposer);

    hydrateConversation();
    updateSystemToggleButton();
    resizeComposer();
    updateClearChatVisibility();
    </script>

    #%env/templates/footer.template%#
  </body>
</html>
