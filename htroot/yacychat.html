<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>YaCy '#[clientname]#': Chat</title>
    #%env/templates/metas.template%#
    <link rel="stylesheet" href="js/styles/a11y-dark.min.css" type="text/css" />
    <style type="text/css">
      /* 1. Global Container */
      .chat-panel {
        width: 100%;
        color: #333333;
        padding: 0 0 32px 0; 
      }
    
      /* 2. Layout Structure */
      .chat-flow {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      
      .chat-messages {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
    
      /* 3. The Message Blocks - Structural Look */
      .chat-turn {
        position: relative;
        border: 1px solid #e0e0e0;
        border-radius: 0px; 
        padding-top: 2px;
        padding-bottom: 12px;
        padding-left: 20px;
        padding-right: 20px;
        margin: 0;
        box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
        transition: all 0.2s;
      }
      .chat-turn:hover {
        box-shadow: 3px 3px 0px rgba(0,0,0,0.15); 
      }
    
      /* 4. Labels (User/Assistant Headers) - Headline Font Consistency */
      .chat-turn legend {
        font-family: inherit; 
        padding: 4px 10px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        border: 1px solid transparent;
        margin-bottom: 8px; /* Increased spacing */
      }
    
      /* --- USER: Lighter Grey Input --- */
      .chat-turn.user {
        background-color: #ECF1F8;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #d1d9e6;
        color: #2c3e50;
      }
      
      .chat-turn.user legend {
        background: #5092CF; 
        color: #ffffff;
        border: 1px solid #5092CF;
      }
    
      /* --- ASSISTANT: Darker Grey Output --- */
      .chat-turn.assistant {
        background-color: #DEE7F3;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #bbccdd;
        color: #000;
      }

      .chat-turn.assistant legend {
        background: #2c3e50; 
        color: #ffffff;
        border: 1px solid #2c3e50;
      }
    
      /* --- SYSTEM: Log Entry Style --- */
      .chat-turn.system {
        background: #fff3cd; 
        border: 1px solid #ffeeba;
        border-left: 5px solid #ffc107;
        color: #856404;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-size: 1.2rem;
      }
    
      /* 5. Typography - All Chat Content is MONOSPACE */
      .chat-body {
        line-height: 1.6;
        font-size: 1.2rem; /* Larger font size */
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
      }

      .chat-body.plain-text {
        white-space: pre-wrap;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
      }

      .chat-body.markdown {
        white-space: normal;
      }

      .chat-body.markdown,
      .chat-body.markdown * {
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace !important; /* Force markdown output and descendants to stay monospace, FTW! */
      }

      .chat-body.markdown.markdown-body {
        max-width: 100%;
        padding: 0;
      }

      .chat-body.markdown h1,
      .chat-body.markdown h2,
      .chat-body.markdown h3,
      .chat-body.markdown h4,
      .chat-body.markdown h5,
      .chat-body.markdown h6,
      .chat-body.markdown p,
      .chat-body.markdown li,
      .chat-body.markdown pre,
      .chat-body.markdown code {
        font-size: 1.2rem;
        line-height: 1.6;
      }

      .chat-body pre {
        background-color: #2c3e50;
        border: 1px solid #dfe2e5;
        border-radius: 4px;
        padding: 2px;
        overflow-x: auto;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        white-space: pre;
      }

      .chat-body code {
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-size: 0.95rem;
        background-color: rgba(27,31,35,0.05);
        padding: 2px 4px;
        border-radius: 4px;
      }
    
      /* 6. Composer Row (inside User fieldset) */
      .composer {
        display: flex;
        gap: 10px;
        align-items: stretch;
      }

      .chat-turn.user:focus-within {
        background-color: #ECF1F8;
        border-left-width: 5px;
        border-left-style: solid;
        border-color: #d1d9e6;
        color: #2c3e50;
      }

      .composer-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .composer textarea {
        flex: 0 0 auto;
        resize: none;
        border: none;
        background: transparent;
        padding: 0;
        margin: 0;
        outline: none;
        overflow-y: hidden;
      }

      .attachment-row {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 0.95rem;
        color: #2c3e50;
      }

      .attachment-row.has-attachment .attachment-clear {
        display: inline-flex;
      }
      .attachment-row.has-attachment .attachment-button {
        display: none;
      }

      .attachment-button,
      .copy-button,
      .user-trim-button {
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
        background: #d1d9e6;
        color: #2c3e50;
        font-weight: 800;
        font-size: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s;
      }

      .attachment-button:hover,
      .copy-button:hover,
      .user-trim-button:hover {
        background: #c3cbd9;
      }

      .attachment-filename {
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-size: 0.95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .attachment-clear {
        display: none;
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
        background: #d1d9e6;
        color: #2c3e50;
        font-weight: 800;
        font-size: 1.25rem;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s, color 0.15s;
      }

      .attachment-clear:hover {
        background: #c3cbd9;
      }

      .copy-button,
      .user-trim-button {
        position: absolute;
        top: -6px;
        right: 8px;
      }

      .hidden-file-input {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }
    
      /* 7. The Button - Industrial Action */
      .composer .btn {
        align-self: stretch; 
        padding: 0 24px;
        border: 2px solid #555; 
        background: #333; 
        color: #fff;
        font-family: 'Roboto Mono', 'Menlo', 'Consolas', monospace;
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
      }
    
      .composer .btn:hover {
        background: #0056b3;
        border-color: #0056b3;
      }
      
      .composer .btn:active {
        background: #004494;
      }
    
      @media (max-width: 900px) {
        .composer {
          flex-direction: column;
        }
        .composer .btn {
          width: 100%;
          border: 2px solid #555;
        }
      }

      .clear-chat-row {
        display: none;
        margin-top: 12px;
        gap: 10px;
        align-items: center;
      }

      .clear-chat-row .btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
    </style>
  </head>
  <body id="IndexControl">
    #%env/templates/header.template%#
    #%env/templates/submenuAI.template%#

    <h2>YaCy Chat</h2>
    <p>Chat with your configured LLM using the local YaCy settings. Requests are sent to the same host that served this page.</p>

      <div class="chat-panel">
        <div class="chat-flow">
          <div class="chat-messages" id="chatMessages" aria-live="polite"></div>
          <form id="chatForm">
            <fieldset class="chat-turn user">
              <legend>User</legend>
              <div class="composer">
                <div class="composer-main" id="composerMain">
                  <textarea class="chat-body" id="userInput" rows="3" placeholder="Ask me anything..." required="required"></textarea>
                  <div class="attachment-row" id="attachmentRow">
                    <button type="button" class="attachment-button" id="addFileButton" aria-label="Attach an image">
                      <span class="glyphicon glyphicon-paperclip" aria-hidden="true"></span>
                    </button>
                    <button type="button" class="attachment-clear" id="clearFileButton" aria-label="Remove attached image">
                      <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
                    </button>
                    <span class="attachment-filename" id="attachmentFilename">Attach a PNG or JPG</span>
                    <input type="file" id="fileInput" class="hidden-file-input" accept="image/*,text/plain,text/markdown"/>
                  </div>
                </div>
                <input type="submit" class="btn btn-primary" id="sendButton" value="Send"/>
              </div>
            </fieldset>
          </form>
          <div class="clear-chat-row" id="clearChatRow">
            <button type="button" class="btn btn-inverse label-warning" id="clearChatButton" aria-label="Clear chat">
              <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
              Clear Chat
            </button>
            <button type="button" class="btn btn-inverse label-success" id="downloadChatButton" aria-label="Download chat">
              <span class="glyphicon glyphicon-download" aria-hidden="true"></span>
              Download Chat
            </button>
            <button type="button" class="btn btn-inverse label-primary" id="uploadChatButton" aria-label="Upload chat">
              <span class="glyphicon glyphicon-upload" aria-hidden="true"></span>
              Upload Chat
            </button>
            <input type="file" id="uploadChatInput" class="hidden-file-input" accept="application/json"/>
            <button type="button" class="btn btn-inverse label-info" id="toggleSystemButton" aria-label="Show system prompt">
              <span class="glyphicon glyphicon-star" aria-hidden="true"></span>
              <span class="toggle-label">Show System</span>
            </button>
          </div>
        </div>
      </div>

    <script src="js/highlight.min.js"></script>
    <script src="js/marked.umd.js"></script>
    <script src="js/index.umd.min.js"></script>
    <script type="text/javascript">
    const SYSTEM_PROMPT = 'You are a smart and helpful chatbot. If possible, use friendly emojies.';
    const defaultApiHost = '';

    const STORAGE_KEY = 'yacychat_recent_pairs';

    const state = {
        messages: [],
        config: {
            apiHost: defaultApiHost,
            model: 'chat',
            systemPrompt: SYSTEM_PROMPT
        },
        busy: false,
        attachment: null,
        assistantSeen: false,
        showSystem: false
    };

    const dom = {
        messages: document.getElementById('chatMessages'),
        form: document.getElementById('chatForm'),
        input: document.getElementById('userInput'),
        sendButton: document.getElementById('sendButton'),
        fileInput: document.getElementById('fileInput'),
        addFileButton: document.getElementById('addFileButton'),
        attachmentFilename: document.getElementById('attachmentFilename'),
        clearFileButton: document.getElementById('clearFileButton'),
        attachmentRow: document.getElementById('attachmentRow'),
        clearChatRow: document.getElementById('clearChatRow'),
        clearChatButton: document.getElementById('clearChatButton'),
        downloadChatButton: document.getElementById('downloadChatButton'),
        uploadChatButton: document.getElementById('uploadChatButton'),
        uploadChatInput: document.getElementById('uploadChatInput'),
        toggleSystemButton: document.getElementById('toggleSystemButton'),
        composerMain: document.getElementById('composerMain')
    };

    if (typeof hljs !== 'undefined') {
        hljs.configure({ ignoreUnescapedHTML: true });
    }

    const languageAlias = {
        js: 'javascript',
        jsx: 'javascript',
        ts: 'typescript',
        tsx: 'typescript',
        sh: 'bash',
        shell: 'bash',
        bash: 'bash',
        csharp: 'csharp',
        'c#': 'csharp',
        'c++': 'cpp',
        py: 'python',
        rb: 'ruby',
        rs: 'rust',
        md: 'markdown',
        yml: 'yaml'
    };

    const languagePromises = {};

    function normalizeLanguage(lang) {
        if (!lang || typeof lang !== 'string') return '';
        const key = lang.trim().toLowerCase();
        return languageAlias[key] || key;
    }

    function ensureLanguage(lang) {
        if (typeof hljs === 'undefined') return Promise.resolve(false);
        const normalized = normalizeLanguage(lang);
        if (!normalized) return Promise.resolve(false);
        if (hljs.getLanguage(normalized)) return Promise.resolve(true);
        if (languagePromises[normalized]) return languagePromises[normalized];
        const loadScript = path => new Promise(resolve => {
            const script = document.createElement('script');
            script.src = path;
            script.async = true;
            script.onload = () => resolve(!!hljs.getLanguage(normalized));
            script.onerror = () => {
                console.warn('Failed to load highlight.js language file:', path);
                resolve(false);
            };
            document.head.appendChild(script);
        });
        const base = (window.location && window.location.origin) ? window.location.origin : '';
        const minSrc = `${base}/js/languages/${normalized}.min.js`;
        const fullSrc = `${base}/js/languages/${normalized}.js`;
        languagePromises[normalized] = loadScript(minSrc).then(success => {
            if (success) return true;
            return loadScript(fullSrc);
        }).then(success => success || !!hljs.getLanguage(normalized));
        return languagePromises[normalized];
    }

    function rehighlightCode(container) {
        if (!container || typeof hljs === 'undefined') return;
        const codeBlocks = Array.from(container.querySelectorAll('pre code'));
        if (!codeBlocks.length) return;
        const tasks = codeBlocks
            .map(block => Array.from(block.classList).find(cls => cls.startsWith('language-')))
            .map(match => match ? normalizeLanguage(match.replace(/^language-/, '')) : '')
            .filter(Boolean)
            .map(lang => ensureLanguage(lang));
        Promise.all(tasks).then(() => {
            codeBlocks.forEach(block => {
                try {
                    hljs.highlightElement(block);
                } catch (err) {
                    // ignore highlight failures
                }
            });
        });
    }

    const markdownSupport = (() => {
        if (typeof marked === 'undefined') {
            return { enabled: false };
        }
        try {
            if (window.markedHighlight && typeof window.markedHighlight.markedHighlight === 'function' && typeof hljs !== 'undefined') {
                marked.use(window.markedHighlight.markedHighlight({
                    langPrefix: 'hljs language-',
                    highlight: (code, lang) => {
                        const language = normalizeLanguage(lang);
                        ensureLanguage(language);
                        if (language && hljs.getLanguage(language)) {
                            return hljs.highlight(code, { language }).value;
                        }
                        // kick off lazy load; will rehighlight after render
                        return escapeHTML(code);
                    }
                }));
            }
        } catch (err) {
            console.warn('Failed to initialize syntax highlighting', err);
        }
        marked.setOptions({
            gfm: true,
            breaks: true,
            smartLists: true,
            mangle: false,
            headerIds: false
        });
        return { enabled: true };
    })();

    function escapeHTML(value) {
        const div = document.createElement('div');
        div.textContent = value || '';
        return div.innerHTML;
    }

    function sanitizeHTML(html) {
        if (!html) return '';
        const template = document.createElement('template');
        template.innerHTML = html;
        const blockedTags = new Set(['script', 'style', 'iframe', 'object', 'embed', 'link', 'meta']);
        const walker = document.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT, null);
        const toRemove = [];
        while (walker.nextNode()) {
            const el = walker.currentNode;
            if (!el || !el.tagName) continue;
            const tag = el.tagName.toLowerCase();
            if (blockedTags.has(tag)) {
                toRemove.push(el);
                continue;
            }
            for (const attr of Array.from(el.attributes)) {
                const name = attr.name.toLowerCase();
                const value = attr.value || '';
                if (name.startsWith('on')) {
                    el.removeAttribute(attr.name);
                    continue;
                }
                if ((name === 'href' || name === 'src') && /^\s*javascript:/i.test(value)) {
                    el.removeAttribute(attr.name);
                }
            }
        }
        toRemove.forEach(node => node.remove());
        return template.innerHTML;
    }

    function renderMarkdown(content) {
        const source = typeof content === 'string' ? content : '';
        if (!markdownSupport.enabled || typeof marked === 'undefined') {
            return escapeHTML(source);
        }
        try {
            return sanitizeHTML(marked.parse(source));
        } catch (err) {
            console.warn('Markdown rendering failed', err);
            return escapeHTML(source);
        }
    }

    function applyMessageContent(target, role, text) {
        if (!target) return;
        if (role === 'assistant') {
            target.classList.add('markdown', 'markdown-body');
            target.classList.remove('plain-text');
            target.innerHTML = renderMarkdown(text);
            rehighlightCode(target);
        } else {
            target.classList.add('plain-text');
            target.classList.remove('markdown');
            target.textContent = text || '';
        }
    }

    function scrollToBottom(smooth = true) {
        window.requestAnimationFrame(() => {
            const behavior = smooth ? 'smooth' : 'auto';
            window.scrollTo({ top: document.documentElement.scrollHeight, behavior });
        });
    }

    function formatTimestamp() {
        const now = new Date();
        const pad = (n, len = 2) => n.toString().padStart(len, '0');
        return `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
    }

    function updateSystemToggleButton() {
        if (!dom.toggleSystemButton) return;
        const icon = dom.toggleSystemButton.querySelector('.glyphicon');
        if (icon) {
            icon.className = `glyphicon ${state.showSystem ? 'glyphicon-star-empty' : 'glyphicon-star'}`;
        }
        const label = state.showSystem ? 'Hide System' : 'Show System';
        dom.toggleSystemButton.querySelector('.toggle-label').textContent = label;
    }

    function appendMessage(role, text, opts = {}) {
        const { skipScroll = false, skipVisibilityUpdate = false } = opts;
        const entry = document.createElement('fieldset');
        entry.className = `chat-turn ${role}`;
        if (role === 'assistant' || role === 'user') {
            entry.style.position = 'relative';
        }
        const legend = document.createElement('legend');
        if (role === 'assistant') {
            legend.textContent = 'Assistant';
        } else if (role === 'user') {
            legend.textContent = 'User';
        } else {
            legend.textContent = 'System';
        }
        entry.appendChild(legend);

        const body = document.createElement('div');
        body.className = 'chat-body';
        applyMessageContent(body, role, text);
        entry.appendChild(body);

        dom.messages.appendChild(entry);
        if (typeof opts.messageIndex === 'number') {
            entry.dataset.messageIndex = String(opts.messageIndex);
        }
        if (role === 'assistant') {
            const copyBtn = document.createElement('button');
            copyBtn.type = 'button';
            copyBtn.className = 'copy-button';
            copyBtn.title = 'Copy answer';
            copyBtn.innerHTML = '<span class="glyphicon glyphicon-copy" aria-hidden="true"></span>';
            copyBtn.addEventListener('click', () => copyAssistant(body.textContent));
            entry.appendChild(copyBtn);
        }
        if (role === 'user' && typeof opts.messageIndex === 'number') {
            const trimBtn = document.createElement('button');
            trimBtn.type = 'button';
            trimBtn.className = 'user-trim-button';
            trimBtn.title = 'Reuse from here';
            trimBtn.innerHTML = '<span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>';
            trimBtn.addEventListener('click', () => trimConversationFromIndex(opts.messageIndex, body.textContent));
            entry.appendChild(trimBtn);
        }
        if (!skipScroll) {
            scrollToBottom();
        }
        if (!skipVisibilityUpdate && role === 'assistant') {
            state.assistantSeen = true;
            updateClearChatVisibility();
        }
        return body;
    }

    function clearAttachment() {
        state.attachment = null;
        dom.fileInput.value = '';
        dom.attachmentFilename.textContent = 'Attach a PNG or JPG';
        dom.attachmentRow.classList.remove('has-attachment');
    }

    async function copyAssistant(text) {
        try {
            await navigator.clipboard.writeText(text || '');
        } catch (err) {
            console.warn('Clipboard copy failed', err);
        }
    }

    function trimConversationFromIndex(index, reuseText) {
        if (typeof index !== 'number' || index < 0) return;
        state.messages = state.messages.slice(0, index);
        state.assistantSeen = state.messages.some(m => m.role === 'assistant');
        state.showSystem = false;
        renderConversation();
        persistConversation();
        updateClearChatVisibility();
        updateSystemToggleButton();
        clearAttachment();
        dom.input.value = reuseText || '';
        resizeComposer();
        showComposer();
    }

    function hideComposer() {
        if (dom.form) dom.form.style.display = 'none';
    }

    function showComposer() {
        if (dom.form) dom.form.style.display = '';
        if (dom.input) dom.input.focus();
    }

    function updateClearChatVisibility() {
        if (!dom.clearChatRow) return;
        dom.clearChatRow.style.display = state.assistantSeen ? 'block' : 'none';
        if (state.assistantSeen) {
            scrollToBottom();
        }
    }

    function clearChatHistory() {
        dom.messages.innerHTML = '';
        state.messages = [];
        state.assistantSeen = false;
        state.showSystem = false;
        localStorage.removeItem(STORAGE_KEY);
        updateClearChatVisibility();
        updateSystemToggleButton();
        dom.input.value = '';
        clearAttachment();
        resizeComposer();
    }

    function downloadChat() {
        const payload = buildRequestPayload();
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `yacychat-${formatTimestamp()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function applyUploadedChat(payload) {
        if (!payload || !Array.isArray(payload.messages)) {
            appendMessage('system', 'Invalid chat file.');
            return;
        }
        clearChatHistory();
        if (payload.model) {
            state.config.model = payload.model;
        }
        for (const msg of payload.messages) {
            if (!msg?.role || msg.content === undefined) continue;
            state.messages.push({ role: msg.role, content: msg.content });
        }
        renderConversation();
        persistConversation();
    }

    async function handleUploadChatFile(event) {
        const file = event.target.files && event.target.files[0];
        dom.uploadChatInput.value = '';
        if (!file) return;
        try {
            const text = await file.text();
            const parsed = JSON.parse(text);
            applyUploadedChat(parsed);
        } catch (err) {
            appendMessage('system', `Failed to load chat file: ${err.message}`);
        }
    }

    function ensureSystemMessage() {
        if (!state.messages.length || state.messages[0].role !== 'system') {
            state.messages.unshift({ role: 'system', content: state.config.systemPrompt });
        }
    }

    async function streamChat(userMessage, assistantNode, options = {}) {
        const { onFirstToken } = options;
        ensureSystemMessage();
        const payload = {
            model: state.config.model,
            messages: [...state.messages, userMessage],
            stream: true
        };
        const headers = { 'Content-Type': 'application/json' };
        const response = await fetch(state.config.apiHost.replace(/\/$/, '') + '/v1/chat/completions', {
            method: 'POST',
            headers,
            body: JSON.stringify(payload)
        });
        if (!response.ok) {
            throw new Error(`Request failed: ${response.status} ${response.statusText}`);
        }
        if (!response.body) {
            throw new Error('Streaming not supported by this browser.');
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let assistantText = '';
        let sawFirstToken = false;
        const parseChunk = chunk => {
            const segments = chunk
                .split(/\n+/)
                .flatMap(line => line.split(/(?=data:)/))
                .map(line => line.trim())
                .filter(Boolean);
            for (const line of segments) {
                if (line === 'data: [DONE]' || line === '[DONE]') {
                    return true;
                }
                const clean = line.replace(/^data:\s*/i, '');
                if (!clean) continue;
                try {
                    const parsed = JSON.parse(clean);
                    const delta = parsed?.choices?.[0]?.delta?.content;
                    if (delta) {
                        if (!sawFirstToken && typeof onFirstToken === 'function') {
                            sawFirstToken = true;
                            applyMessageContent(assistantNode, 'assistant', '');
                            onFirstToken();
                        }
                        assistantText += delta;
                        applyMessageContent(assistantNode, 'assistant', assistantText);
                        scrollToBottom(false);
                    }
                } catch (err) {
                    console.warn('Failed to parse line', line, err);
                }
            }
            return false;
        };
        let done = false;
        while (!done) {
            const { value, done: readerDone } = await reader.read();
            if (readerDone) break;
            const chunk = decoder.decode(value, { stream: true });
            done = parseChunk(chunk);
        }
        if (!sawFirstToken && typeof onFirstToken === 'function') {
            onFirstToken();
        }
        state.messages.push(userMessage);
        state.messages.push({ role: 'assistant', content: assistantText });
        persistConversation();
        renderConversation();
    }

    function resizeComposer() {
        const minHeight = 24;
        dom.input.style.height = 'auto';
        const measured = dom.input.scrollHeight || minHeight;
        dom.input.style.height = `${Math.max(minHeight, measured)}px`;
    }

    function buildUserMessage(promptText) {
        if (state.attachment) {
            const parts = [{ type: 'text', text: promptText }];
            if (state.attachment.kind === 'image' && state.attachment.dataUrl) {
                parts.push({ type: 'image_url', image_url: { url: state.attachment.dataUrl } });
            } else if (state.attachment.kind === 'text' && state.attachment.textContent) {
                parts.push({ type: 'text', text: state.attachment.textContent });
            }
            return {
                role: 'user',
                content: parts
            };
        }
        return { role: 'user', content: promptText };
    }

    function buildRequestPayload() {
        ensureSystemMessage();
        return {
            model: state.config.model,
            messages: state.messages.map(m => ({ role: m.role, content: m.content })),
            stream: true
        };
    }

    function messageText(content) {
        if (typeof content === 'string') return content;
        if (Array.isArray(content)) {
            const textPart = content.find(part => part?.type === 'text');
            return textPart?.text || '';
        }
        if (content && typeof content === 'object' && typeof content.text === 'string') {
            return content.text;
        }
        return '';
    }

    function collectRecentPairs() {
        const pairs = [];
        let pendingUser = null;
        for (const msg of state.messages) {
            if (msg.role === 'user') {
                pendingUser = messageText(msg.content);
            } else if (msg.role === 'assistant' && pendingUser !== null) {
                pairs.push({ user: pendingUser, assistant: messageText(msg.content) });
                pendingUser = null;
            }
        }
        return pairs.slice(-3);
    }

    function renderConversation() {
        dom.messages.innerHTML = '';
        state.assistantSeen = state.messages.some(m => m.role === 'assistant');
        for (let i = 0; i < state.messages.length; i++) {
            const msg = state.messages[i];
            if (msg.role === 'system' && !state.showSystem) continue;
            appendMessage(msg.role, messageText(msg.content), { skipScroll: true, skipVisibilityUpdate: true, messageIndex: i });
        }
        updateClearChatVisibility();
        updateSystemToggleButton();
        scrollToBottom();
    }

    function persistConversation() {
        try {
            const pairs = collectRecentPairs();
            localStorage.setItem(STORAGE_KEY, JSON.stringify(pairs));
        } catch (err) {
            console.warn('Failed to persist conversation', err);
        }
    }

    function hydrateConversation() {
        let stored = null;
        try {
            stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
        } catch (err) {
            console.warn('Failed to parse stored conversation', err);
        }
        if (!Array.isArray(stored) || !stored.length) return;
        for (const pair of stored) {
            if (pair?.user) {
                state.messages.push({ role: 'user', content: pair.user });
            }
            if (pair?.assistant) {
                state.messages.push({ role: 'assistant', content: pair.assistant });
            }
        }
        ensureSystemMessage();
        renderConversation();
    }

    function formatUserPreview(promptText) {
        if (state.attachment?.name) {
            return `${promptText}\n[Attachment: ${state.attachment.name}]`;
        }
        return promptText;
    }

    async function handleFileChange(event) {
        const file = event.target.files && event.target.files[0];
        dom.fileInput.value = '';
        if (!file) {
            clearAttachment();
            return;
        }
        try {
            const attachment = await buildAttachment(file);
            if (!attachment) {
                appendMessage('system', 'Please upload an image, .txt, or .md file.');
                clearAttachment();
                return;
            }
            state.attachment = attachment;
            dom.attachmentFilename.textContent = attachment.name;
            dom.attachmentRow.classList.add('has-attachment');
        } catch (err) {
            appendMessage('system', `Failed to read file: ${err.message}`);
            clearAttachment();
        }
    }

    function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(file);
        });
    }

    function readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsText(file);
        });
    }

    async function buildAttachment(file) {
        const name = file.name || 'attachment';
        const mime = (file.type || '').toLowerCase();
        const isImage = mime.startsWith('image/');
        const isText = mime.startsWith('text/') || name.endsWith('.txt') || name.endsWith('.md');
        if (isImage) {
            const dataUrl = await readFileAsDataURL(file);
            return { kind: 'image', name, dataUrl };
        }
        if (isText) {
            const textContent = await readFileAsText(file);
            return { kind: 'text', name, textContent };
        }
        return null;
    }

    dom.form.addEventListener('submit', async event => {
        event.preventDefault();
        if (state.busy) return;
        const prompt = dom.input.value.trim();
        if (!prompt) return;
        const userMessage = buildUserMessage(prompt);
        const preview = formatUserPreview(prompt);
        state.busy = true;
        dom.sendButton.disabled = true;
        appendMessage('user', preview);
        dom.input.value = '';
        clearAttachment();
        resizeComposer();
        const assistantNode = appendMessage('assistant', 'waiting for an answer...');
        hideComposer();
        try {
            await streamChat(userMessage, assistantNode, { onFirstToken: showComposer });
        } catch (err) {
            appendMessage('system', `Error: ${err.message}`);
            showComposer();
        } finally {
            state.busy = false;
            dom.sendButton.disabled = false;
            showComposer();
        }
    });

    dom.addFileButton.addEventListener('click', () => {
        dom.fileInput.click();
    });
    dom.fileInput.addEventListener('change', handleFileChange);
    dom.clearFileButton.addEventListener('click', clearAttachment);
    dom.clearChatButton?.addEventListener('click', clearChatHistory);
    dom.downloadChatButton?.addEventListener('click', downloadChat);
    dom.uploadChatButton?.addEventListener('click', () => dom.uploadChatInput?.click());
    dom.uploadChatInput?.addEventListener('change', handleUploadChatFile);
    dom.toggleSystemButton?.addEventListener('click', () => {
        state.showSystem = !state.showSystem;
        renderConversation();
    });

    dom.input.addEventListener('input', resizeComposer);
    dom.input.addEventListener('keydown', event => {
        if (event.isComposing) return;
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (typeof dom.form.requestSubmit === 'function') {
                dom.form.requestSubmit(dom.sendButton);
            } else {
                dom.form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            }
        }
    });
    dom.composerMain?.addEventListener('dragover', event => {
        event.preventDefault();
    });
    dom.composerMain?.addEventListener('drop', async event => {
        event.preventDefault();
        const file = event.dataTransfer?.files && event.dataTransfer.files[0];
        if (!file) return;
        try {
            const attachment = await buildAttachment(file);
            if (!attachment) {
                appendMessage('system', 'Please drop an image, .txt, or .md file.');
                return;
            }
            state.attachment = attachment;
            dom.attachmentFilename.textContent = attachment.name;
            dom.attachmentRow.classList.add('has-attachment');
        } catch (err) {
            appendMessage('system', `Failed to read file: ${err.message}`);
            clearAttachment();
        }
    });
    window.addEventListener('resize', resizeComposer);

    hydrateConversation();
    updateSystemToggleButton();
    resizeComposer();
    updateClearChatVisibility();
    </script>

    #%env/templates/footer.template%#
  </body>
</html>
